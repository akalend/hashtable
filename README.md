# simple hashtable

tools/generate.py - генерация тестового файла
tests - unit tests

В качестве хранилища данных используется упрощенная хеш-таблица, основанная на разреженных массивах. В данном случае, взята Хеш-функция CRC32. Старший байт используется как ключ 1 в 64К массиве строк. 

Bucket - массив элементов 64К х 64, взято с запасом. Было произведено с десяток замеров с разными длиннами строк на массиве ~ 130-140Мб, в котором от 2-3 млн строк. Коллизия, при использовании 32 битного ключа в качестве хеш-функции составила 30 - 35 строк.

Как возможное расширение данного проекта, если коллизия уж слишком велика, то можно последние 8 байт линиии массива использовать, как указатель на списочную структуру, где будут храниться ключи.

Каждая строка Bucket массива имеет 64 элемента следующей структуры:
```c
typedef struct  {
	uint16_t key;  	/* вторая часть ключа */
	char data[2];  	/* первые два байта от данных, на случай коллизии */
} ht_element;

```
Как показали эксперименты, коллизии с 32-битными ключами на 3 млн строк - 2-3 элемента, а чаще их нет. По этому, еще сохраняются два байта данных. При такой проверке коллизии вообще нет (крайне маловероятна). Теоретически вероятность коллиции: Общее Кол-во строк / 2^48

Если будут коллизии с проверкой первых двух байт, то можно кол-во байт увеличить до 6 или другое число, опереляется константой HT_VALUE_SIZE.  

*Недостатки* - не оптимально распределена память

## Варианты

Предложенный выше вариант заточен под конкретную задачу и не совсем оптимален для широкого использования. Если мы за ранее не знаем объем используемого текста, то можно использовать алгоритм хеш-таблицы с открытой адресацией (как реализовано в STL). Первоночально величина Bucket массива = 1024. По мере его заполнения, величина массива увеличиваетсяв два раза, при этом меняется хеш-функция.


Как вариант, можно построить хештаблицу, основанную на списках, т.е. в Bucket хранися массив указателей на списочную структуру:

```c
typedef struct  {
	uint16_t key;  		/* вторая часть ключа */
	char data[2];  		/* первые два байта от данных, на случай коллизии */
	ht_element* next;	/* указатель на следующий элемент списка*/
} ht_element;

```
*Плюсы* - более оптимально распределена память, нет избыточности
*минусы* - чуть-чуть медленее, но для данной задачи вполне применима. Но, если часто использовать вставку/удаление, то необходимо аллоцировать/освобождать память. Для этого лучше использовать пулы аллокаторов, а то может возникнуть проблема дефрагментации памяти.


